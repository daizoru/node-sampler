// Generated by CoffeeScript 1.3.3
(function() {
  var contains, delay, error, events, inspect, log, moment, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  events = require('events');

  moment = require('moment');

  _ref1 = require('./misc/toolbox'), delay = _ref1.delay, contains = _ref1.contains;

  module.exports = (function(_super) {

    __extends(exports, _super);

    function exports(options) {
      this.fire = __bind(this.fire, this);

      this.checkBuffer = __bind(this.checkBuffer, this);

      this.resume = __bind(this.resume, this);

      this.pause = __bind(this.pause, this);
      this.store = options.record.store;
      this.speed = options.speed;
      this.looped = options.looped;
      this.enabled = true;
      this.paused = false;
      this.next = false;
      this.latency = 0;
      this.buffer = [];
      this.bufferMax = 3;
    }

    exports.prototype.pause = function() {
      this.paused = true;
      return this.latency = 0;
    };

    exports.prototype.resume = function() {
      if (!this.enabled) {
        this.emit('error', "cannot resume: we are not enabled");
        return;
      }
      this.paused = false;
      if (!this.next) {
        this.next = this.store.first;
      }
      this.emit('begin');
      return this.fire();
    };

    exports.prototype.checkBuffer = function() {
      if (this.buffer.length < this.bufferMax) {
        return log("we have some room to bufferize");
      }
    };

    exports.prototype.fire = function() {
      var evt, fired,
        _this = this;
      if (!this.enabled) {
        this.emit('error', "cannot fire: we are not enabled");
        return;
      }
      if (this.paused) {
        log("cannot fire: paused");
        return;
      }
      evt = this.next;
      this.emit('data', {
        timestamp: evt.timestamp,
        data: evt.data
      });
      fired = moment();
      return this.store.next(evt, function(next) {
        var dbLatency, realDelay, theoricDelay;
        if (!next) {
          log("error, no more next in the DB..");
          _this.emit('error', "store.next gave us nothing");
          return;
        }
        if (next === _this.store.first) {
          if (!_this.looped) {
            _this.enabled = false;
            _this.emit('end');
            return;
          }
        }
        theoricDelay = (next.timestamp - evt.timestamp) / _this.speed;
        dbLatency = (moment() - fired) + _this.latency;
        realDelay = theoricDelay - dbLatency;
        if (realDelay < 0) {
          _this.latency = realDelay;
          realDelay = 0;
        } else {
          _this.latency = 0;
        }
        _this.next = next;
        return delay(realDelay, function() {
          return _this.fire();
        });
      });
    };

    return exports;

  })(events.EventEmitter);

}).call(this);
