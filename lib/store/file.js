// Generated by CoffeeScript 1.3.3
(function() {
  var BinaryTree, Memory, Stream, YAML, contains, delay, error, events, fs, getFormat, inspect, log, moment, snappy, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  Stream = require('stream').Stream;

  events = require('events');

  fs = require('fs');

  moment = require('moment');

  YAML = require('libyaml');

  snappy = require('snappy');

  _ref1 = require('../misc/toolbox'), delay = _ref1.delay, contains = _ref1.contains;

  BinaryTree = require('../misc/btree');

  Memory = require('./memory');

  getFormat = function(path) {
    var _base;
    if (!path) {
      return "UNKNOW";
    }
    switch (typeof path.split === "function" ? typeof (_base = path.split(".").slice(-1)[0]).toLowerCase === "function" ? _base.toLowerCase() : void 0 : void 0) {
      case "js":
      case "json":
        return "JSON";
      case "yml":
      case "yaml":
        return "YAML";
      case "smp":
      case "sample":
        return "SAMPLER";
      default:
        return "UNKNOW";
    }
  };

  /* TODO use async, streaming file reading:
  
  writeStream = fs.createWriteStream(__dirname + "/outFile.txt");
  // every time "data" is read, this event fires
  readStream.on('data', function(textData) {
    console.log("Found some text!");
    writeStream.write(textData);
  });
  
  // the reading is finished...
  readStream.on('close', function () {
    writeStream.end(); // ...close up the write, too!
    console.log("I finished.");
  });
  
  
  "Partially buffered access methods are different. 
  They do not treat data input as a discrete event, 
  but rather as a series of events which occur as 
  the data is being read or written. They allow us
  to access data as it is being read from 
  disk/network/other I/O.
  Partially buffered methods, such as readSync() 
  and read() allow us to specify the size of the
  buffer, and read data in small chunks. They
  allow for more control (e.g. reading a file in
  non-linear order by skipping back and forth in
  the file)." (from http://book.mixu.net/ch9.html)
  */


  module.exports = (function(_super) {

    __extends(exports, _super);

    function exports(path, options) {
      var k, v,
        _this = this;
      this.path = path;
      if (options == null) {
        options = {};
      }
      this._writeEvent = __bind(this._writeEvent, this);

      this.sync = __bind(this.sync, this);

      this.config = {
        filename: function() {}
      };
      for (k in options) {
        v = options[k];
        this.config[k] = v;
      }
      this.events = [];
      this.first = false;
      this.last = false;
      this._length = 0;
      this.buff = [];
      this.buffMax = 1;
      this.isWriting = false;
      this.initialized = false;
      this.flushing = {
        version: 1,
        saved: 0
      };
      this.format = getFormat(this.path);
      switch (this.format) {
        case "YAML":
          this.saveSnapshot = YAML.writeFile;
          this.loadSnapshot = YAML.readFile;
          break;
        case "JSON":
          this.saveSnapshot = function(path, data, cb) {
            var dumpString;
            dumpString = JSON.stringify(data);
            return fs.writeFile(path, dumpString, function(err) {
              return cb(err);
            });
          };
          this.loadSnapshot = function(path, cb) {
            return fs.readFile(path, function(err, data) {
              var obj;
              obj = {};
              if (!err) {
                try {
                  obj = JSON.parse(data);
                } catch (exc) {
                  err = "could not load json: " + exc;
                }
              }
              return cb(err, obj);
            });
          };
          break;
        case "SAMPLER":
          this.saveSnapshot = function(path, data, cb) {
            var compressed;
            compressed = snappy.compressSync(data);
            return fs.writeFile(path, compressed, function(err) {
              return cb(err);
            });
          };
          this.loadSnapshot = function(path, cb) {
            return fs.readFile(path, function(err, raw) {
              var data, obj;
              obj = {};
              if (!err) {
                data = snappy.decompressSync(raw, snappy.parsers.string);
                if (data) {
                  try {
                    obj = JSON.parse(data);
                  } catch (exc) {
                    err = "invalid json file: " + exc;
                  }
                }
              }
              return cb(err, obj);
            });
          };
          break;
        default:
          log("unknow format: " + this.format);
          throw "unknow format: " + this.format;
          return;
      }
      delay(1, function() {
        return _this.load();
      });
    }

    exports.prototype.load = function() {
      var _this = this;
      return this.loadSnapshot(this.path, function(err, data) {
        var event, _i, _len, _ref2;
        if (err) {
          1;

        }
        if (data != null) {
          if (data.events != null) {
            if (data.events.length > 0) {
              _this.events = [];
              _ref2 = data.events;
              for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
                event = _ref2[_i];
                _this.write(moment(event[0]), event[1]);
              }
            }
          }
        }
        return _this.ready();
      });
    };

    exports.prototype.sync = function() {
      var event, snapshot, version, _i, _len, _ref2,
        _this = this;
      if (!this.initialized) {
        this.emit('synced', -1);
        return;
      }
      if (this.isWriting) {
        this.emit('synced', -1);
        return;
      }
      this.isWriting = true;
      snapshot = {
        events: []
      };
      this.buff = [];
      _ref2 = this.events;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        event = _ref2[_i];
        snapshot.events.push([0 + event.timestamp, event.data]);
      }
      version = this.count;
      return this.saveSnapshot(this.path, snapshot, function(err) {
        _this.flushing.saved = version;
        _this.isWriting = false;
        if (err) {
          _this.emit('synced', -1);
          return _this.emit('error', err);
        } else {
          return _this.emit('synced', version);
        }
      });
    };

    exports.prototype._writeEvent = function(event) {
      this.events.push(event);
      this.buff.push(event);
      this.count();
      return false;
    };

    return exports;

  })(Memory);

}).call(this);
