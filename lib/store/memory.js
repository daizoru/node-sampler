// Generated by CoffeeScript 1.3.3
(function() {
  var BinaryTree, Stream, contains, delay, error, events, inspect, log, moment, toolbox, _ref, _ref1,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  _ref = require('util'), log = _ref.log, error = _ref.error, inspect = _ref.inspect;

  Stream = require('stream').Stream;

  events = require('events');

  moment = require('moment');

  toolbox = require('../misc/toolbox');

  _ref1 = require('../misc/toolbox'), delay = _ref1.delay, contains = _ref1.contains;

  BinaryTree = require('../misc/btree');

  module.exports = (function(_super) {

    __extends(exports, _super);

    function exports(options) {
      var k, v,
        _this = this;
      if (options == null) {
        options = {};
      }
      this.sync = __bind(this.sync, this);

      this.count = __bind(this.count, this);

      this.length = __bind(this.length, this);

      this._writeEvent = __bind(this._writeEvent, this);

      this.write = __bind(this.write, this);

      this.ready = __bind(this.ready, this);

      this.config = {};
      for (k in options) {
        v = options[k];
        this.config[k] = v;
      }
      this.initialized = false;
      this.events = [];
      this.first = false;
      this.last = false;
      this._length = 0;
      this.flushing = {
        version: 1
      };
      this.events = [];
      delay(0, function() {
        return _this.ready();
      });
    }

    exports.prototype.ready = function() {
      this.initialized = true;
      return this.emit('ready');
    };

    exports.prototype.write = function(timestamp, data) {
      var event;
      event = {
        timestamp: timestamp,
        data: data
      };
      this.first = this.events[0] ? this.events[0] : event;
      this.first.previous = event;
      event.next = this.first;
      this.last = this.events[this.events.length - 1];
      if (!this.last) {
        this.last = event;
      }
      this.last.next = event;
      event.previous = this.last;
      if (this.first && this.last) {
        this._length = this.last.timestamp - this.first.timestamp;
      }
      return this._writeEvent(event);
    };

    exports.prototype._writeEvent = function(event) {
      this.events.push(event);
      this.count();
      return true;
    };

    exports.prototype.previous = function(event, onComplete) {
      return delay(0, function() {
        return onComplete(event.previous);
      });
    };

    exports.prototype.next = function(event, onComplete) {
      return delay(0, function() {
        return onComplete(event.next);
      });
    };

    exports.prototype.length = function() {
      return this._length;
    };

    exports.prototype.count = function() {
      var version;
      version = 0 + this.flushing.version;
      this.flushing.version++;
      return version;
    };

    exports.prototype.sync = function() {
      return this.emit('synced', this.count());
    };

    return exports;

  })(events.EventEmitter);

}).call(this);
